{"posts":[{"title":"OpenFegin 进行远程服务调用","content":"Feign与OpenFeign Feign 是一种声明式服务调用组件，是在服务消费者（客户端）定义服务绑定接口并通过注解的方式进行配置，以实现远程服务的调用。它在 RestTemplate 的基础上做了进一步的封装。通过 Feign，我们只需要声明一个接口并通过注解进行简单的配置（类似于 Dao 接口上面的 Mapper 注解一样）即可实现对 HTTP 接口的绑定。 通过 Feign，我们可以像调用本地方法一样来调用远程服务，而完全感觉不到这是在进行远程调用。 使用 OpenFegin 进行远程服务调用时，常用注解如下表。 OpenFeign 实现远程服务调用 下面通过一个实例，来演示下通过 OpenFeign 是如何实现远程服务调用的。 在 spring-cloud-demo2 下创建一个名为 micro-service-cloud-consumer-dept-feign 的 Spring Boot 模块，并在 pom.xml 中添加以下依赖。 <?xml version=\"1.0\" encoding=\"UTF-8\"?> 4.0.0 spring-cloud-demo2 net.biancheng.c 0.0.1-SNAPSHOT 在 micro-service-cloud-consumer-dept-feign 下的类路径（即 /resources 目录）下，添加一个 application.yml，配置内容如下。 server: port: 80 eureka: client: register-with-eureka: false #服务消费者可以不向服务注册中心注册服务 service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ fetch-registry: true #服务消费者客户端需要去检索服务 在 net.biancheng.c.service 包下创建一个名为 DeptFeignService 的接口，并在该接口上使用 @FeignClient 注解实现对服务接口的绑定，代码如下。 package net.biancheng.c.service; import net.biancheng.c.entity.Dept; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import java.util.List; //添加为容器内的一个组件 @Component // 服务提供者提供的服务名称，即 application.name @FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPT&quot;) public interface DeptFeignService { //对应服务提供者（8001、8002、8003）Controller 中定义的方法 @RequestMapping(value = &quot;/dept/get/{id}&quot;, method = RequestMethod.GET) public Dept get(@PathVariable(&quot;id&quot;) int id); } 在编写服务绑定接口时，需要注意以下 2 点： 在 @FeignClient 注解中，value 属性的取值为：服务提供者的服务名，即服务提供者配置文件（application.yml）中 spring.application.name 的取值。 接口中定义的每个方法都与服务提供者（即 micro-service-cloud-provider-dept-8001 等）中 Controller 定义的服务方法对应。 在 net.biancheng.c.controller 包下，创建一个名为 DeptController_Consumer 的 Controller 类，代码如下。 package net.biancheng.c.controller; import net.biancheng.c.entity.Dept; import net.biancheng.c.service.DeptFeignService; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; import java.util.List; @RestController public class DeptController_Consumer { } 在主启动类上添加 @EnableFeignClients 注解开启 OpenFeign 功能，代码如下。 package net.biancheng.c; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients //开启 OpenFeign 功能 public class MicroServiceCloudConsumerDeptFeignApplication { } Spring Cloud 应用在启动时，OpenFeign 会扫描标有 @FeignClient 注解的接口生成代理，并注人到 Spring 容器中。 依次启动服务注册中心集群、服务提供者以及 micro-service-cloud-consumer-dept-feign，启动完成后，使用浏览器访问“http://eureka7001.com/consumer/dept/list”，结果如下图。 ","link":"https://xuetongyao.github.io/post/mgAe6A0Cx/"},{"title":"HashMap","content":" title: HashMap源码&amp;底层数据结构分析 category: Java tag: Java集合 感谢 changfubai 对本文的改进做出的贡献！ HashMap 简介 HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。 HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。 HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， HashMap 总是使用 2 的幂作为哈希表的大小。 底层数据结构分析 JDK1.8 之前 JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。 HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 JDK 1.8 HashMap 的 hash 方法源码: JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 对比一下 JDK1.7 的 HashMap 的 hash 方法源码. 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 JDK1.8 之后 相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。 当链表长度大于阈值（默认为 8）时，会首先调用 treeifyBin()方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 resize() 方法对数组扩容。相关源码这里就不贴了，重点关注 treeifyBin()方法即可！ 类的属性： loadFactor 加载因子 loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。 loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。 threshold threshold = capacity * loadFactor，当 Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 Node 节点类源码: 树节点类源码: HashMap 源码分析 构造方法 HashMap 中有四个构造方法，它们分别如下： putMapEntries 方法： put 方法 HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。 对 putVal 方法添加元素的分析如下： 如果定位到的数组位置没有元素 就直接插入。 如果定位到的数组位置有元素就和要插入的 key 比较，如果 key 相同就直接覆盖，如果 key 不相同，就判断 p 是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。 说明:上图有两个小问题： 直接覆盖之后应该就会 return，不会有后续操作。参考 JDK8 HashMap.java 658 行（issue#608）。 当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。参考 HashMap 的 treeifyBin() 方法（issue#1087）。 我们再来对比一下 JDK1.7 put 方法的代码 对于 put 方法的分析如下： ① 如果定位到的数组位置没有元素 就直接插入。 ② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。 get 方法 resize 方法 进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。 HashMap 常用方法测试 ","link":"https://xuetongyao.github.io/post/hashmap/"},{"title":"Mapreduce","content":"Hadoop解决大规模数据分布式计算的方案是MapReduce。MapReduce既是一个编程模型，又是一个计算框架。也就是说，开发人员必须基于MapReduce编程模型进行编程开发，然后将程序通过MapReduce计算框架分发到Hadoop集群中运行。我们先看一下作为编程模型的MapReduce。 MapReduce编程模型 MapReduce是一种非常简单又非常强大的编程模型。 简单在于其编程模型只包含map和reduce两个过程，map的主要输入是一对&lt;key , value&gt;值，经过map计算后输出一对&lt;key , value&gt;值；然后将相同key合并，形成&lt;key , value集合&gt;；再将这个&lt;key , value集合&gt;输入reduce，经过计算输出零个或多个&lt;key , value&gt;对。 但是MapReduce同时又是非常强大的，不管是关系代数运算（SQL计算），还是矩阵运算（图计算），大数据领域几乎所有的计算需求都可以通过MapReduce编程来实现。 我们以WordCount程序为例。WordCount主要解决文本处理中的词频统计问题，就是统计文本中每一个单词出现的次数。如果只是统计一篇文章的词频，几十K到几M的数据，那么写一个程序，将数据读入内存，建一个Hash表记录每个词出现的次数就可以了，如下图。 但是如果想统计全世界互联网所有网页（数万亿计）的词频数（这正是google这样的搜索引擎典型需求），你不可能写一个程序把全世界的网页都读入内存，这时候就需要用MapReduce编程来解决。 WordCount的MapReduce程序如下。 其核心是一个map函数，一个reduce函数。 map函数的输入主要是一个&lt;key , value&gt;对，在这个例子里，value是要统计的所有文本中的一行数据，key在这里不重要，我们忽略。 map函数的计算过程就是，将这行文本中的单词提取出来，针对每个单词输出一个&lt;word , 1&gt;这样的&lt;key , value&gt;对。 MapReduce计算框架会将这些&lt;word , 1&gt;收集起来，将相同的word放在一起，形成&lt;word , &lt;1,1,1,1,1,1,1.....&gt;&gt;这样的&lt;key , value集合&gt;数据，然后将其输入给reduce函数。 这里的reduce的输入参数values就是由很多个1组成的集合，而key就是具体的单词word。 reduce函数的计算过程就是，将这个集合里的1求和，再将单词（word）和这个和（sum）组成一个&lt;key , value&gt;(&lt;word , sum&gt;)输出。每一个输出就是一个单词和它的词频统计总和。 假设有两个block的文本数据需要进行词频统计，MapReduce计算过程如下图。 MapReduce计算过程 一个map函数可以针对一部分数据进行运算，这样就可以将一个大数据切分成很多块（这也正是HDFS所做的），MapReduce计算框架为每个块分配一个map函数去计算，从而实现大数据的分布式计算。 上面提到MapReduce编程模型将大数据计算过程切分为map和reduce两个阶段，在map阶段为每个数据块分配一个map计算任务，然后将所有map输出的key进行合并，相同的key及其对应的value发送给同一个reduce任务去处理。 这个过程有两个关键问题需要处理 如何为每个数据块分配一个map计算任务，代码是如何发送数据块所在服务器的，发送过去是如何启动的，启动以后又如何知道自己需要计算的数据在文件什么位置（数据块id是什么） 处于不同服务器的map输出的&lt;key , value&gt; ，如何把相同的key聚合在一起发送给reduce任务 这两个关键问题正好对应文章中“MapReduce计算过程”一图中两处“MapReduce框架处理”。 我们先看下MapReduce是如何启动处理一个大数据计算应用作业的。 MapReduce作业启动和运行机制 我们以Hadoop1为例，MapReduce运行过程涉及以下几类关键进程： 大数据应用进程：启动用户MapReduce程序的主入口，主要指定Map和Reduce类、输入输出文件路径等，并提交作业给Hadoop集群。 JobTracker进程：根据要处理的输入数据量启动相应数量的map和reduce进程任务，并管理整个作业生命周期的任务调度和监控。JobTracker进程在整个Hadoop集群全局唯一。 TaskTracker进程：负责启动和管理map进程以及reduce进程。因为需要每个数据块都有对应的map函数，TaskTracker进程通常和HDFS的DataNode进程启动在同一个服务器，也就是说，Hadoop集群中绝大多数服务器同时运行DataNode进程和TaskTacker进程。 如下图所示。 具体作业启动和计算过程如下： 应用进程将用户作业jar包存储在HDFS中，将来这些jar包会分发给Hadoop集群中的服务器执行MapReduce计算。 应用程序提交job作业给JobTracker。 JobTacker根据作业调度策略创建JobInProcess树，每个作业都会有一个自己的JobInProcess树。 JobInProcess根据输入数据分片数目（通常情况就是数据块的数目）和设置的reduce数目创建相应数量的TaskInProcess。 TaskTracker进程和JobTracker进程进行定时通信。 如果TaskTracker有空闲的计算资源（空闲CPU核），JobTracker就会给他分配任务。分配任务的时候会根据TaskTracker的服务器名字匹配在同一台机器上的数据块计算任务给它，使启动的计算任务正好处理本机上的数据。 TaskRunner收到任务后根据任务类型（map还是reduce），任务参数（作业jar包路径，输入数据文件路径，要处理的数据在文件中的起始位置和偏移量，数据块多个备份的DataNode主机名等）启动相应的map或者reduce进程。 map或者reduce程序启动后，检查本地是否有要执行任务的jar包文件，如果没有，就去HDFS上下载，然后加载map或者reduce代码开始执行。 如果是map进程，从HDFS读取数据（通常要读取的数据块正好存储在本机）。如果是reduce进程，将结果数据写出到HDFS。 通过以上过程，MapReduce可以将大数据作业计算任务分布在整个Hadoop集群中运行，每个map计算任务要处理的数据通常都能从本地磁盘上读取到。而用户要做的仅仅是编写一个map函数和一个reduce函数就可以了，根本不用关心这两个函数是如何被分布启动到集群上的，数据块又是如何分配给计算任务的。这一切都由MapReduce计算框架完成。 MapReduce数据合并与连接机制 在WordCount例子中，要统计相同单词在所有输入数据中出现的次数，而一个map只能处理一部分数据，一个热门单词几乎会出现在所有的map中，这些单词必须要合并到一起进行统计才能得到正确的结果。 事实上，几乎所有的大数据计算场景都需要处理数据关联的问题，简单如WordCount只要对key进行合并就可以了，复杂如数据库的join操作，需要对两种类型（或者更多类型）的数据根据key进行连接。 MapReduce计算框架处理数据合并与连接的操作就在map输出与reduce输入之间，这个过程有个专门的词汇来描述，叫做shuffle。 MapReduce shuffle过程 每个map任务的计算结果都会写入到本地文件系统，等map任务快要计算完成的时候，MapReduce计算框架会启动shuffle过程，在map端调用一个Partitioner接口，对map产生的每个&lt;key , value&gt;进行reduce分区选择，然后通过http通信发送给对应的reduce进程。这样不管map位于哪个服务器节点，相同的key一定会被发送给相同的reduce进程。reduce端对收到的&lt;key , value&gt;进行排序和合并，相同的key放在一起，组成一个&lt;key , value集合&gt;传递给reduce执行。 MapReduce框架缺省的Partitioner用key的哈希值对reduce任务数量取模，相同的key一定会落在相同的reduce任务id上，实现上，这样的Partitioner代码只需要一行，如下所示。 shuffle是大数据计算过程中发生奇迹的地方，不管是MapReduce还是Spark，只要是大数据批处理计算，一定会有shuffle过程，让数据关联起来，数据的内在关系和价值才会呈现出来。不理解shuffle，就会在map和reduce编程中产生困惑，不知道该如何正确设计map的输出和reduce的输入。shuffle也是整个MapReduce过程中最难最消耗性能的地方，在MapReduce早期代码中，一半代码都是关于shuffle处理的。 ","link":"https://xuetongyao.github.io/post/mapreduce/"},{"title":"JVM","content":" category: Java tag: JVM 大白话带你认识JVM 原文地址：https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28 前言 如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及而不深究，但会尽量效率地把知识点都抛出来 一、JVM的基本介绍 JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现··· 好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。 1.1 Java文件是如何被运行的 比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。 那我们的 JVM 是不认识文本文件的，所以它需要一个 编译 ，让其成为一个它会读二进制文件的 HelloWorld.class ① 类加载器 如果 JVM 想要执行这个 .class 文件，我们需要将其装进一个 类加载器 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进JVM里面来。 ② 方法区 方法区 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等 类加载器将 .class 文件搬过来就是先丢到这一块上 ③ 堆 堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 线程不安全 的 ④ 栈 栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。 我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。 ⑤ 程序计数器 主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 线程独享 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。 小总结 Java文件经过编译后变成 .class 字节码文件 字节码文件通过类加载器被搬运到 JVM 虚拟机中 虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行 1.2 简单的代码例子 一个简单的学生类 一个main方法 执行main方法的步骤如下: 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载 JVM 找到 App 的主程序入口，执行main方法 这个main中的第一条语句为 Student student = new Student(&quot;tellUrDream&quot;) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 指向方法区中的 Student 类的类型信息 的引用 执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。 执行sayName() 其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。 二、类加载器的介绍 之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定 2.1 类加载器的流程 从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分统称为连接 2.1.1 加载 将class文件加载到内存 将静态数据结构转化成方法区中运行时的数据结构 在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口 2.1.2 链接 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查 准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的） 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行） 2.1.3 初始化 初始化其实就是执行类构造器方法的&lt;clinit&gt;()的过程，而且要保证执行前父类的&lt;clinit&gt;()方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 static int a 由默认初始化的0变成了显式初始化的3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。 注意：字节码文件中初始化方法有两种，非静态资源初始化的&lt;init&gt;和静态资源初始化的&lt;clinit&gt;，类构造器方法&lt;clinit&gt;()不同于类的构造器，这些方法都是字节码文件中只能给JVM识别的特殊方法。 2.1.4 卸载 GC将无用对象从内存中卸载 2.2 类加载器的加载顺序 加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的 BootStrap ClassLoader：rt.jar Extension ClassLoader: 加载扩展的jar包 App ClassLoader：指定的classpath下面的jar包 Custom ClassLoader：自定义的类加载器 2.3 双亲委派机制 当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。 这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。 其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 java.lang.String ： 尝试运行当前类的 main 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的java.lang.String，然而发现这个里面并没有 main 方法。 三、运行时数据区 3.1 本地方法栈和程序计数器 比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。 程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。 如果执行的是native方法，那这个指针就不工作了。 3.2 方法区 方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。 3.3 虚拟机栈和虚拟机堆 一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。 3.3.1 虚拟机栈的概念 它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈 3.3.2 虚拟机栈存在的异常 如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 StackOverflowError （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 OutOfMemoryError。 3.3.3 虚拟机栈的生命周期 对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。 这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。 3.3.4 虚拟机栈的执行 我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。 栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。 3.3.5 局部变量的复用 局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。 虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。 3.3.6 虚拟机堆的概念 JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为年轻代和老年代，而非堆内存则为永久代。年轻代又会分为Eden和Survivor区。Survivor也会分为FromPlace和ToPlace，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 8:1:1。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整 堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数 移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。 3.3.7 Eden年轻代的介绍 当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。 当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。 而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。 补充说明：关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15 3.3.8 如何判断一个对象需要被干掉 图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。 在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法 1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。 2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。 （了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种： 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量） 方法区中静态变量所引用的对象（静态变量） 方法区中常量引用的对象 本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收） 已启动的且未终止的Java线程 这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程） 3.3.9 如何宣告一个对象的真正死亡 首先必须要提到的是一个名叫 finalize() 的方法 finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。 补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为 deprecated ，且 java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 finalize 来的更加的轻量及可靠。 判断一个对象的死亡至少需要两次标记 如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。 GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。 如果确定对象已经死亡，我们又该如何回收这些垃圾呢 3.4 垃圾回收算法 不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法 3.4.1 标记清除算法 标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。 其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。 不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图 此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题 3.4.2 复制算法 为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。 这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了 不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。 3.4.3 标记整理算法 复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存 3.4.4 分代收集算法 这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。 说白了就是八仙过海各显神通，具体问题具体分析了而已。 3.5 （了解）各种各样的垃圾回收器 HotSpot VM中的垃圾回收器，以及适用场景 到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old 从jdk9开始，G1收集器成为默认的垃圾收集器 目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。 3.6 （了解）JVM的常用参数 JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。 参数名称 含义 默认值 说明 -Xms 初始堆大小 物理内存的1/64(&lt;1GB) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. -Xmx 最大堆大小 物理内存的1/4(&lt;1GB) 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 -Xmn 年轻代大小(1.4or later) 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了 -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 -XX:SurvivorRatio Eden区与Survivor区的大小比值 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 -XX:+DisableExplicitGC 关闭System.gc() 这个参数需要严格的测试 -XX:PretenureSizeThreshold 对象超过多大是直接在旧生代分配 0 单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. -XX:ParallelGCThreads 并行收集器的线程数 此值最好配置与处理器数目相等 同样适用于CMS -XX:MaxGCPauseMillis 每次年轻代垃圾回收的最长时间(最大暂停时间) 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. 其实还有一些打印及CMS方面的参数，这里就不以一一列举了 四、关于JVM调优的一些方面 根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块 所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。 4.1 调整最大堆内存和最小堆内存 -Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB)) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单 开发过程中，通常会将 -Xms 与 -Xmx两个参数配置成相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。 我们执行下面的代码 注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小 设置一个VM options的参数 再次启动main方法 这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中 这时候申请到的内存为18M，空闲内存为4.214195251464844M 我们此时创建一个字节数组看看，执行下面的代码 此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小 这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。 此时我们再跑一下这个代码 此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。 4.2 调整新生代和老年代的比值 -XX:NewRatio --- 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值 例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 4.3 调整Survivor区和Eden区的比值 -XX:SurvivorRatio（幸存代）--- 设置两个Survivor区和eden的比值 例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10 4.4 设置年轻代和老年代的大小 -XX:NewSize --- 设置年轻代大小 -XX:MaxNewSize --- 设置年轻代最大值 可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。 4.5 小总结 根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10 在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。 一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。 4.6 永久区的设置 初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。 tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。 4.7 JVM的栈参数调优 4.7.1 调整每个线程栈空间的大小 可以通过-Xss：调整每个线程栈空间的大小 JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右 4.7.2 设置线程栈的大小 这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了 4.8 (可以直接跳过了)JVM其他参数介绍 形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。 4.8.1 设置内存页的大小 4.8.2 设置原始类型的快速优化 4.8.3 设置关闭手动GC 4.8.4 设置垃圾最大年龄 4.8.5 加快编译速度 加快编译速度 4.8.6 改善锁机制性能 4.8.7 禁用垃圾回收 4.8.8 设置堆空间存活时间 4.8.9 设置对象直接分配在老年代 4.8.10 设置TLAB占eden区的比例 4.8.11设置是否优先YGC finally 真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。 ","link":"https://xuetongyao.github.io/post/jvm/"},{"title":"Big Data","content":" 日更原创大数据领域文章&amp;大数据行业最新动态 打造价值40万Offer朋友圈,数据人的宝藏朋友圈 关注公众号~ 加我好友~ 大数据成神之路目录 图片打不开，点这里 八千里路云和月|从零到大数据专家学习路径指南 我们在学习Flink的时候，到底在学习什么? 我们在学习Spark的时候，到底在学习什么？ 大数据开发基础篇 🎿Java基础 📝NIO 📖并发 🎸JVM 💵分布式 💾Zookeeper 👊RPC 🎨Netty 💻Linux Java基础 NIO 并发容器 JVM 分布式 zookeeper RPC Netty Linux 大数据框架学习篇 Hadoop Hive Spark Flink HBase Kafka Zookeeper 大数据开发实战进阶篇 这里的文章主要是我平时发表在公众号，博客等的文章，精心挑选，以飨读者。 Flink实战进阶 Spark实战进阶 Kafka实战进阶 OLAP实战进阶 大数据开发面试篇 面试系列合集 大数据算法 公众号2021年大数据精品文章合集 2020精品文章合集 2021精品文章合集 硬刚系列文章合集 第一部分: 大数据开发基础篇 一、Java基础 大数据成神之路-Java高级特性增强(多线程) 大数据成神之路-Java高级特性增强(Synchronized关键字) 大数据成神之路-Java高级特性增强(volatile关键字) 大数据成神之路-Java高级特性增强(锁) 大数据成神之路-Java高级特性增强(ArrayList/Vector) 大数据成神之路-Java高级特性增强(LinkedList) 大数据成神之路-Java高级特性增强(HashMap) 大数据成神之路-Java高级特性增强(HashSet) 大数据成神之路-Java高级特性增强(LinkedHashMap) 二、NIO基础 大数据成神之路-Java高级特性增强-NIO大纲 NIO概览 Java NIO之Buffer(缓冲区) Java NIO之Channel(通道) ava NIO之Selector(选择器) Java NIO之拥抱Path和Files 三、Java并发容器 大数据成神之路-Java高级特性增强(并发容器大纲) 大数据成神之路-Java高级特性增强(LinkedBlockingQueue) 大数据成神之路-Java高级特性增强(LinkedBlockingDeque) 大数据成神之路-Java高级特性增强(CopyOnWriteArraySet) 大数据成神之路-Java高级特性增强(CopyOnWriteArrayList) 大数据成神之路-Java高级特性增强(ConcurrentSkipListSet) 大数据成神之路-Java高级特性增强(ConcurrentSkipListMap) 大数据成神之路-Java高级特性增强(ConcurrentLinkedQueue) 大数据成神之路-Java高级特性增强(ConcurrentHashMap) 大数据成神之路-Java高级特性增强(ArrayBlockingQueue) 四、JVM深度解析和面试点 先来10篇基础热身 JVM内存结构 HotSpot虚拟机对象探秘 垃圾收集策略与算法 HotSpot垃圾收集器 内存分配与回收策略 JVM性能调优 类文件结构 类加载的时机 类加载的过程 类加载器 再来5篇详细解说 java类的加载机制 JVM内存结构 GC算法 垃圾收集器 jvm调优-命令大全 Java GC 分析 五、分布式理论基础和原理 分布式系统的一些基本概念 分布式系统理论基础一： 一致性、2PC和3PC 分布式系统理论基础二-CAP 分布式系统理论基础三-时间、时钟和事件顺序 分布式系统理论进阶 - Paxos 分布式系统理论进阶 - Raft、Zab 分布式系统理论进阶：选举、多数派和租约 分布式锁的解决方案 分布式锁的解决方案(二) 分布式事务的解决方案 分布式ID生成器解决方案 六、大数据框架开发基础-Zookeeper 安装和运行 zookeeper服务 zookeeper应用程序 zookeeper开发实例 zookeeper集群构建 七、大数据框架开发基础-RPC RPC简单介绍 RPC的原理和框架 手把手教你实现一个简单的RPC 八、大数据框架基石之网路通信-Netty 关于Netty我们都需要知道什么 Netty源码解析-概述篇 Netty源码解析1-Buffer Netty源码解析2-Reactor Netty源码解析3-Pipeline Netty源码解析4-Handler综述 Netty源码解析5-ChannelHandler Netty源码解析6-ChannelHandler实例之LoggingHandler Netty源码解析7-ChannelHandler实例之TimeoutHandler Netty源码解析8-ChannelHandler实例之CodecHandler Netty源码解析9-ChannelHandler实例之MessageToByteEncoder 第二部分:大数据框架学习篇 一、Hadoop 分布式文件存储系统 —— HDFS 分布式计算框架 —— MapReduce 集群资源管理器 —— YARN Hadoop 单机伪集群环境搭建 Hadoop 集群环境搭建 HDFS 常用 Shell 命令 HDFS Java API 的使用 基于 Zookeeper 搭建 Hadoop 高可用集群 Hadoop级简入门 MapReduce编程模型和计算框架架构原理 二、Hive Hive 简介及核心概念 Linux 环境下 Hive 的安装部署 Hive CLI 和 Beeline 命令行的基本使用 Hive 常用 DDL 操作 Hive 分区表和分桶表 Hive 视图和索引 Hive常用 DML 操作 Hive 数据查询详解 三、Spark Spark Core : Spark 简介 Spark 开发环境搭建 弹性式数据集 RDD RDD 常用算子详解 Spark 运行模式与作业提交 Spark 累加器与广播变量 基于 Zookeeper 搭建 Spark 高可用集群 Spark SQL : DateFrame 和 DataSet Structured API 的基本使用 Spark SQL 外部数据源 Spark SQL 常用聚合函数 Spark SQL JOIN 操作 Spark Streaming ： Spark Streaming 简介 Spark Streaming 基本操作 Spark Streaming 整合 Flume Spark Streaming 整合 Kafka 四、Flink Flink 核心概念综述 Flink 开发环境搭建 Flink Data Source Flink Data Transformation Flink Data Sink Flink 窗口模型 Flink 状态管理与检查点机制 Flink Standalone 集群部署 Flink当前最火的实时计算引擎-入门篇 Flink从入门到放弃(入门篇1)-Flink是什么 Flink从入门到放弃(入门篇2)-本地环境搭建&amp;构建第一个Flink应用 Flink从入门到放弃(入门篇3)-DataSetAPI Flink从入门到放弃(入门篇4)-DataStreamAPI Flink集群部署 Flink重启策略 Flink的分布式缓存 Flink中的窗口 Flink中的Time Flink集群搭建的HA Flink中的时间戳和水印 Flink广播变量 Flink-Kafka-Connector Flink-Table-&amp;-SQL实战 15-Flink实战项目之实时热销排行 16-Flink-Redis-Sink 17-Flink消费Kafka写入Mysql Flink当前最火的实时计算引擎-放弃篇 Flink漫谈系列1-概述 Flink漫谈系列2-watermark Flink漫谈系列3-state 五、HBase Hbase 简介 HBase 系统架构及数据结构 HBase 基本环境搭建 (Standalone /pseudo-distributed mode) HBase 集群环境搭建 HBase 常用 Shell 命令 HBase Java API Hbase 过滤器详解 HBase 协处理器详解 HBase 容灾与备份 HBase的 SQL 中间层 —— Phoenix Spring/Spring Boot 整合 Mybatis + Phoenix 六、Kafka Kafka基本原理 ： Kafka 简介 基于 Zookeeper 搭建 Kafka 高可用集群 Kafka 生产者详解 Kafka 消费者详解 深入理解 Kafka 副本机制 分布式消息队列Kafka原理及与流式计算的集成 ： Apache-Kafka简介 Apache-Kafka核心概念 Apache-Kafka安装和使用 Apache-Kafka编程实战 Apache-Kafka核心组件和流程(副本管理器) Apache-Kafka核心组件和流程-协调器 Apache-Kafka核心组件和流程-控制器 Apache-Kafka核心组件和流程-日志管理器 七、Zookeeper Zookeeper 简介及核心概念 Zookeeper 单机环境和集群环境搭建 Zookeeper 常用 Shell 命令 Zookeeper Java 客户端 —— Apache Curator Zookeeper ACL 权限控制 八、大数据算法 大数据算法 大数据算法 第三部分:大数据开发实战进阶篇 一、Flink实战进阶文章合集 Flink实战合集 点我查看Flink实战合集 菜鸟供应链实时技术架构演进 趣头条实战-基于Flink+ClickHouse构建实时数据平台 ApacheFlink新场景-OLAP引擎 说说Flink DataStream的八种物理分区逻辑 State Processor API：如何读取，写入和修改 Flink 应用程序的状态 Flink滑动窗口原理与细粒度滑动窗口的性能问题 基于Flink快速开发实时TopN 使用 Apache Flink 开发实时 ETL Flink Source/Sink探究与实践：RocketMQ数据写入HBase Spark/Flink广播实现作业配置动态更新 Flink全链路延迟的测量方式 Flink原理-Flink中的数据抽象及数据交换过程 Flink SQL Window源码全解析 Flink DataStream维度表Join的简单方案 Apache Flink的内存管理 Flink1.9整合Kafka实战 Apache Flink在小米的发展和应用 基于Kafka+Flink+Redis的电商大屏实时计算案例 Flink实战-壳找房基于Flink的实时平台建设 用Flink取代Spark Streaming！知乎实时数仓架构演进 Flink实时数仓-美团点评实战 来将可留姓名？Flink最强学习资源合集! 数据不撒谎，Flink-Kafka性能压测全记录! 菜鸟在物流场景中基于Flink的流计算实践 基于Flink构建实时数据仓库 Flink/Spark 如何实现动态更新作业配置 二、Spark实战进阶文章合集 Spark实战合集 点我查看Spark实战合集 如果你在准备面试，好好看看这130道题 ORC文件存储格式的深入探究 基于SparkStreaming+Kafka+HBase实时点击流案例 HyperLogLog函数在Spark中的高级应用 我们常说的海量小文件的根源是什么？ Structured Streaming | Apache Spark中处理实时数据的声明式API Spark面对OOM问题的解决方法及优化总结 Spark 动态资源分配(Dynamic Resource Allocation) 解析 Apache Spark在海致大数据平台中的优化实践 Spark/Flink广播实现作业配置动态更新 Spark SQL读数据库时不支持某些数据类型的问题 这个面试问题很难么 | 如何处理大数据中的数据倾斜 Spark难点 | Join的实现原理 面试注意点 | Spark&amp;Flink的区别拾遗 Spark Checkpoint的运行原理和源码实现 阿里云Spark Shuffle的优化 使用Kafka+Spark+Cassandra构建实时处理引擎 基于HBase和Spark构建企业级数据处理平台 SparkSQL在字节跳动的应用实践和优化实战 SparkRDD转DataSet/DataFrame的一个深坑 Spark和Flink的状态管理State的区别和应用 Kafka+Spark Streaming管理offset的几种方法 从 PageRank Example谈Spark应用程序调优 Spark调优|SparkSQL参数调优 Flink/Spark 如何实现动态更新作业配置 Stream SQL的执行原理与Flink的实现 Spark将Dataframe数据写入Hive分区表的方案 Spark中几种ShuffleWriter的区别你都知道吗？ SparkSQL的3种Join实现 周期性清除Spark Streaming流状态的方法 Structured Streaming之状态存储解析 Spark SQL重点知识总结 SparkSQL极简入门 Spark Shuffle在网易的优化 广告点击数实时统计：Spark StructuredStreaming + Redis Streams Spark内存调优 Structured Streaming 实现思路与实现概述 Spark之数据倾斜调优 你不得不知道的知识-零拷贝 Spark Streaming消费Kafka数据的两种方案 三、Kafka实战进阶文章合集 Kafka实战合集 点我查看Kafka实战合集 四、数据仓库实战系列 数据仓库实战合集 点我查看数据仓库实战合集 五、OLAP实战文章系列 六、硬刚系列文章合集 硬刚系列文章合集 《硬刚Presto|Presto原理&amp;调优&amp;面试&amp;实战全面升级版》 《硬刚Apache Iceberg | 技术调研&amp;在各大公司的实践应用大总结》 《硬刚ClickHouse | 4万字长文ClickHouse基础&amp;实践&amp;调优全视角解析》 《硬刚数据仓库|SQL Boy的福音之数据仓库体系建模&amp;实施&amp;注意事项小总结》 《硬刚Hive | 4万字基础调优面试小总结》 《硬刚用户画像(一) | 标签体系下的用户画像建设小指南》 《硬刚用户画像(二) | 基于大数据的用户画像构建小百科全书》 《我们在学习Spark的时候，到底在学习什么？》 《我们在学习Flink的时候，到底在学习什么？》 七、2020精品文章合集 2020精品文章合集 实时计算篇 Structured Streaming | Apache Spark中处理实时数据的声明式API HyperLogLog函数在Spark中的高级应用 基于SparkStreaming+Kafka+HBase实时点击流案例 基于Flink SQL构建实时数据仓库 Flink异步之矛-锋利的Async I/O Spark SQL快速入门系列之Hive 基于SparkStreaming+Kafka+HBase实时点击流案例 三万字长文 | Spark性能优化实战手册 Flink整合OozieShellAction提交任务带Kerberos认证 Spark源码阅读的正确打开方式 消息队列常见面试问题小集合 Flink1.10和Hive集成一些需要注意的点 Flink事件时间、水印和迟到数据处理 Flink使用Broadcast State实现流处理配置实时更新 实战 | MySQL Binlog通过Canal同步HDFS Flink最难知识点再解析 | 时间/窗口/水印/迟到数据处理 Hive on Spark参数调优姿势小结 Flink Logback日志与邮件报警配置 Kafka设计-恰好一次和事务消息 基于Canal和Kafka实现MySQL的Binlog近实时同步 一个基于RabbitMQ的可复用的事务消息方案 Spark性能优化总结 Flink常见异常和错误信息小结 Spark SQL快速入门系列之Hive 实时计算双星-Flink VS Spark 部署模式对比 PID算法和Spark实现反压的原理 关于SparkSQL的开窗函数，你应该知道这些! Spark SQL是如何选择join策略的？ Spark on Hive &amp; Hive on Spark，傻傻分不清楚 来看看一个大二学生的Spark练习题 Flink 自定义触发器实现带超时时间的 CountWindow Spark Kafka 基于Direct自己管理offset Apache Kylin | 麒麟出没，必有祥瑞 Flink 参数配置和常见参数调优 利用InfluxDB+Grafana搭建Flink on YARN作业监控大屏 网站日志实时分析之Flink处理实时热门和PVUV统计 大数据量下的集合过滤—Bloom Filter 实时数仓链路分享：kafka =&gt;SparkStreaming=&gt;kudu集成kerberos Flink CEP 原理和案例详解 ProcessFunction：Flink最底层API使用踩坑记录 Flink 1.10之改进的TaskManager内存模型与配置 打通实时流处理log4j-flume-kafka-structured-streaming 如何设计实时数据平台（设计篇） 如何设计实时数据平台（技术篇） SparkSQL内核解析-执行全过程概述 SparkSQL内核解析之逻辑计划 Flink-1.10中的StreamingFileSink相关特性 Kafka下的生产消费者模式与订阅发布模式 Kafka+Spark Streaming如何保证exactly once语义 Flink之实时统计热门商品的TopN SparkSQL的自适应执行-Adaptive Execution Kafka KSQL实战 ELK+FileBeat+Kafka分布式系统搭建图文教程 HDFS应用场景、原理、基本架构及使用方法 数据模型⽆法复⽤，归根结底还是设计问题 Hadoop支持Lzo压缩配置及案例 快看 | Java连接集成Kerberos的HA HDFS方案 Kafka消费者分区分配策略及自定义分配策略 Spark Streaming整合log4j、Flume与Kafka的案例 面试必知的 Spark SQL 几种 Join 实现 Flink在大规模状态数据集下的checkpoint调优 Write-Ahead Log(WAL预写日志)的工作原理 Kafka常见的导致重复消费原因和解决方案 Spark-submit 参数调优完整攻略 Kafka数据可靠性保证三板斧-ACK/ISR/HW Spark常见错误问题汇总 HBase操作组件：Hive、Phoenix、Lealone Redis系列 | 缓存穿透、击穿、雪崩、预热、更新、降级 Kafka工作流程及文件存储机制 Redis6.0主从、哨兵、集群搭建和原理 Spark Streaming官方编程指南 【从0开始の全记录】Flume+Kafka+Spark+Spring Boot 统计网页访问量项目 Spark+Kudu的广告业务项目实战笔记(一) 大数据入门：Spark+Kudu的广告业务项目实战笔记(二) 大数据入门：Spark+Kudu的广告业务项目实战笔记(三) 大数据入门：Spark+Kudu的广告业务项目实战笔记(四) 大数据入门：Spark+Kudu的广告业务项目实战笔记(五) 大数据入门：Spark+Kudu的广告业务项目实战笔记(六) Flink 1.11新特性之SQL Hive Streaming简单示例 SparkSQL 整体运行架构和底层实现 离线计算篇 ORC文件存储格式的深入探究 Hadoop支持Lzo压缩配置及案例 神策数据分享 | 标签体系应用与建设(文末附下载链接) 环形缓冲区-Hadoop Shuffle过程中的利器 eBay | 实践Hadoop任务的性能翻倍之路 PDFT/Paxos/Raft-分布式一致性协议解析 谈谈经典限流方法—漏桶、令牌桶与Guava RateLimiter的实现 轻量级异步屏障快照（ABS）算法解析 Hadoop小文件利器Ozone 数据指标体系建设 Hbase FAQ热门问答小集合 设计HBase RowKey需要注意的二三事 HBase优化笔记 HBase生产环境优化不完全指南 Hive SQL50道练习题 Hive on Spark参数调优小结 Hadoop(CDH)分布式环境搭建(简单易懂,绝对有效) ConcurrentHashMap锁机制进化的考量 HBASE列族不能太多的真相 基于ClickHouse的用户行为分析实践 HBase的系统架构全视角解读 Kylin Cube构建原理+调优 Hadoop支持Lzo压缩配置及案例 Apache Hudi 架构设计和基本概念 HiveSQL常用优化方法全面总结 MapReduce性能优化大纲 从NoSQL运动谈分布式系统的CAP、BASE理论 HDFS读写数据过程原理分析 数据中台建设五步法 Step by Step 实现基于 Cloudera 5.8.2 的企业级安全大数据平台 - Kerberos的整合 一篇文章全面了解监控知识体系 Sqoop 使用shell命令的各种参数的配置及使用方法 Hive小知识之分桶抽样 数据仓库和数据集市建模体系化总结 Phoenix(云HBase SQL)核心功能原理及应用场景介绍 基于实际业务场景下的Flume部署 斗转星移 | 三万字总结Kafka各个版本差异 Spark SQL自定义函数UDF、UDAF聚合函数以及开窗函数的使用 SparkSQL用UDAF实现Bitmap函数 一文了解Kafka核心概念和角色 Apache Spark 内存管理详解 经典限流方法——漏桶、令牌桶与Guava RateLimiter的实现 ZooKeeper在HBase集群中的作用 从B+树到LSM树，及LSM树在HBase中的应用 Hadoop Namenode元数据持久化机制与SecondaryNamenode的作用详解 干掉ELK | 使用Prometheus+Grafana搭建监控平台 盘点：SQL on Hadoop中用到的主要技术 用HiveSQL计算连续天数问题的方法 浅谈Linux cgroup机制与YARN的CPU资源隔离 京东JDHBase异地多活实践 Kafka的分区数是不是越多越好？ 一文俯瞰Elasticsearch核心原理 不可不说的Java&quot;锁&quot;事 数据仓库篇 一文了解数据库和数据仓库 数据仓库系统的实现与使用(含OLAP重点讲解) Data Lake 三剑客—Delta、Hudi、Iceberg 对比分析 数据也有温度？Elasticsearch 5.x 版本中的冷热数据架构 数据冷热分离技术 冷热数据分离 | Alluxio元数据管理策略 数据之眼 | 数据探查服务的设计 元数据存储系统管理演变升级 数据湖 | 一文读懂Data Lake的概念、特征、架构与案例 用户行为数据采集系统 创业公司数据仓库的建设 Kylin使用Spark构建Cube 实时统计分析系统-Apache Druid Elasticsearch索引和检索优化与压测监控总结 面试题篇 我们常说的海量小文件的根源是什么？ 如果你在准备面试，好好看看这130道题 你可能需要知道的Kafka面试题与部分答案整理 28道关于ZooKeeper的面试题 【数据白皮书重磅分享】推荐|埋点|用研|标签 一份优秀的简历该长成什么样 1万2千字长文助力春招 | Netty面试篇 消息队列面面观 关于技术面试的一点点体会 早点建立自己的知识体系 Filter(过滤)|Project(映射)|Pushdowns(谓词下推) 阅读源码｜Spark 与 Flink 的 RPC 实现 三万六千字通关MySQL面试 深入理解CAP理论和适用场景 HDFS的SecondaryNameNode作用，你别答错了 Kafka三种可视化监控管理工具Monitor/Manager/Eagle Kafka体系架构详细分解 Kafka笔记—可靠性、幂等性和事务 Kafka体系架构详细分解 Kafka面试题系列(进阶篇) Kafka面试题系列(基础篇) 面试知识点 | Kafka的数据存储与索引设计 面试必考点:HBase Compaction机制 ZooKeeper需要关注的点 MySQL中InnoDB及索引深入剖析 Kafka面试题系列(进阶篇2) MySql的Binlog日志工具分析：Canal、Maxwell、Databus、DTS Redis中的管道Pipeline操作 查看YARN任务日志的几种方式 Yarn 使用 Cgroup 实现任务资源限制 分析和定位线上作业 OOM 问题利器-MAT 浅谈ZooKeeper中Kafka相关信息的存储 JVM架构体系与GC命令小总结 其他 腾讯如何用Elasticsearch挖掘万亿数据价值？ Apache Beam 大数据处理一站式分析 Apache Hudi 架构设计和基本概念 Apache Hudi 架构设计和基本概念 MySQL8.0发布，你熟悉又陌生的Hash Join？ 转载一个看不懂的文章：F1 Query Apache Hudi | 统一批和近实时分析的增量处理框架 寻找5亿次访问中，访问次数最多的人 聊聊阿里巴巴的全链路压测 年轻人你渴望力量吗 | 我读过的一些书推荐 数据算法之反转排序 | 寻找相邻单词的数量 MySQL Binlog同步HDFS的方案 循环查询数据的性能问题及优化 推荐系统 embedding 技术实践总结 Prometheus+Clickhouse实现业务告警 亿级用户的分布式数据存储解决方案 基于大数据的用户画像构建小百科全书 魅族持续交付平台建设实践 八、2021精品文章合集 2021精品文章合集 汇总部分 八千里路云和月|从零到大数据专家学习路径指南 我们在学习Flink的时候，到底在学习什么? 我们在学习Spark的时候，到底在学习什么？ 一线互联网公司面试进阶全攻略 【大数据成神之路】第一版更新完毕 关于技术面试的一点点体会 早点建立自己的知识体系 专题部分 Hadoop系列 最新Hive/Hadoop高频面试点小集合 Hadoop所支持的几种压缩格式 【大数据面试之对线面试官】MapReduce/HDFS/YARN面试题70连击 HDFS的SecondaryNameNode作用，你别答错了 Yarn 使用 Cgroup 实现任务资源限制 查看YARN任务日志的几种方式 大数据哔哔集20210106 - Hadoop3.0有哪些新特性 Hive系列 Hive性能调优 | 数据倾斜 面试必备技能-HiveSQL优化 Hive常用参数调优十二板斧 HBase 面试必考点:HBase Compaction机制 Hbase性能优化百科全书 ES等 触类旁通Elasticearch之吊打同行系列：原理篇 触类旁通ElasticSearch之吊打同行系列：操作篇 触类旁通Elasticearch之吊打同行系列：搜索篇 Kafka/消息队列 面试知识点 | Kafka的数据存储与索引设计 Kafka面试题系列(基础篇) Kafka面试题系列(进阶篇) Kafka面试题系列(进阶篇2) 关于MQ面试的几件小事 | 消息队列的用途、优缺点、技术选型 关于MQ面试的几件小事 | 如何保证消息不丢失 关于MQ面试的几件小事 | 如何保证消息按顺序执行 一道真实的阿里面试题 | 如何保证消息队列的高可用 你可能需要知道的Kafka面试题与部分答案整理 消息队列面面观 Kafka三种可视化监控管理工具Monitor/Manager/Eagle Kafka体系架构详细分解 Kafka笔记—可靠性、幂等性和事务 Kafka体系架构详细分解 Kafka面试题系列(进阶篇) Kafka面试题系列(基础篇) 面试知识点 | Kafka的数据存储与索引设计 斗转星移 | 三万字总结Kafka各个版本差异 Spark 面试必知的 Spark SQL 几种 Join 实现 面试注意点 | Spark&amp;Flink的区别拾遗 Spark如何协调来完成整个Job的运行详解 独孤九剑-Spark面试80连击(上) 独孤九剑-Spark面试80连击(下) Spark的Cache和Checkpoint区别和联系拾遗 Spark Job 逻辑执行图和数据依赖解析 Spark Job 物理执行图详解 Spark Shuffle过程详解 Flink 【大数据面试题】Flink企业级面试题60连击 全网第一|Flink学习面试灵魂40问答案 面试别人说他熟悉Flink，我问了他Flink如何实现exactly-once语义 阅读源码｜Spark与Flink的RPC实现 Flink性能调优小小总结 生产上的坑才是真的坑 | 盘一盘Flink那些经典线上问题 我们在学习Flink的时候，到底在学习什么？ 数据仓库/数据湖 数据湖存储架构选型 数据湖架构、战略和分析的8大错误认知 数据湖在大数据典型场景下应用调研个人笔记 数据湖VS数据仓库？湖仓一体了解一下 后端相关 三万六千字通关MySQL面试 分析和定位线上作业 OOM 问题利器-MAT 浅谈ZooKeeper中Kafka相关信息的存储 JVM架构体系与GC命令小总结 深入理解CAP理论和适用场景 ZooKeeper需要关注的点 MySQL中InnoDB及索引深入剖析 MySql的Binlog日志工具分析：Canal、Maxwell、Databus、DTS 一致性协议算法-2PC、3PC、Paxos、Raft、ZAB、NWR超详细解析 MySQL数据库性能优化史诗级大总结 不便分类的其他 十道海量数据处理面试题 这个面试问题很难么 | 如何处理大数据中的数据倾斜 面试系列：十个海量数据处理方法大总 我们常说的海量小文件的根源是什么？ 28道关于ZooKeeper的面试题 【数据白皮书重磅分享】推荐|埋点|用研|标签 1万2千字长文助力春招 | Netty面试篇 Filter(过滤)|Project(映射)|Pushdowns(谓词下推) 代达罗斯之殇-大数据领域小文件问题解决攻略 面试综合系列 【对线面试官】阿里面试经历，有些人走一步看一步就挂了 关于技术面试的一点点体会 助力秋招-独孤九剑破剑式 | 10家企业面试真题 如果你在准备面试，好好看看这130道题 简历系列 一份优秀的简历该长成什么样 你过来，我给你看个宝贝 面试系列合集 一、Hadoop Hadoop面试题总结（一） Hadoop面试题总结（二）——HDFS Hadoop面试题总结（三）——MapReduce Hadoop面试题总结（四）——YARN Hadoop面试题总结（五）——优化问题 二、Zookeeper Zookeeper面试题总结（一） 三、Hive Hive面试题总结（一） Hive面试题总结（二） 四、HBase HBase面试题总结（一） 五、Flume Flume面试题总结（一） 六、Kafka Kafka面试题总结（一） Kafka面试题总结（二） 七、Spark Spark面试题总结（一） Spark面试题总结（二） Spark面试题总结（三） Spark面试题总结（四） Spark性能优化： Spark面试题总结（五）——几种常见的数据倾斜情况及调优方式 Spark面试题总结（六）——Shuffle配置调优 Spark面试题总结（七）——程序开发调优 Spark面试题总结（八）——运行资源调优 本系列的大纲会根据实际情况进行调整，欢迎大家关注~ 声明 文档中参考引用了大量网络上的博客和文章，大部分给出了出处，有些没写，如果造成了侵权行为，请您联系我，立即删除~ 扫我关注公众号 关注公众号：每天定时推送Hadoop/Spark/Flink等最新的大数据领域最新动态和精品技术文章! 扫我加我好友,打造价值40万Offer朋友圈! 如果对你有用，欢迎请我喝杯咖啡 备注Gitub，感谢您～ 扫我加群 备注来自GitHub加群，小助手会拉你进大数据讨论组，一起学习交流，期待你的到来~ 为什么有这个文档 以前这里只是几个txt文档 是我面试腾讯阿里美团等公司大数据开发工程师的过程中总结出来的大数据开发的必知必会的知识点~ 后续更新在微信公众号更新，欢迎关注~ 言而总之 大数据成神之路 该系列文章将为希望从事大数据开发或者由后端转型为大数据开发的工程师们指出需要学习的知识点和路径，本系列文章同时致敬我曾经在网络上看到无数个Java和大数据系列文章，深受启发同时也收货很多。 ","link":"https://xuetongyao.github.io/post/big-data/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... <!-- more --> Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://xuetongyao.github.io/post/hello-gridea/"}]}